rules_version = '2';

service cloud.firestore {
  // Super Admin Check
  function isSuperAdmin() {
    return request.auth != null && request.auth.token.email == 'contact@didyouquit.com';
  }

  match /databases/{database}/documents {
    // Super Admin has full acccess to everything
    match /{document=**} {
      allow read, write: if isSuperAdmin();
    }
    
    // User Profiles
    match /users/{userId} {
      // Anyone can read a user's profile (for public page)
      allow read: if true;
      // Only the user can write their own profile
      // Admin can update "isHidden" status (handled by wildcard above? No, specific match takes precedence? No, overlapping matches allow access if ANY allow. So wildcard above handles admin.)
      allow write: if request.auth != null && request.auth.uid == userId;

      // Social Graph Rules
      match /following/{targetId} {
        allow read: if true;
        allow write: if request.auth != null && request.auth.uid == userId;
      }
      
      match /followers/{followerId} {
        allow read: if true;
        allow write: if request.auth != null && request.auth.uid == followerId;
      }
    }
    
    // Resolutions
    match /resolutions/{resolutionId} {
      // Anyone can read resolutions (for public page)
      // In a stricter app, might want to check if the owner's profile is public, 
      // but requirements imply public sharing.
      allow read: if true;
      
      // Create: User must be authenticated and setting their own uid
      allow create: if request.auth != null && request.resource.data.uid == request.auth.uid;
      
      // Update/Delete: Only the owner
      allow update, delete: if request.auth != null && resource.data.uid == request.auth.uid;
    }
    match /app_config/{configId} {
      allow read: if true;
      allow write: if false; // Only admin via console
    }

    // Forums
    match /forum_topics/{topicId} {
      allow read: if true;
      allow create: if request.auth != null;
      allow update: if request.auth != null && (
        resource.data.author.uid == request.auth.uid ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['commentCount'])
      );
      allow delete: if request.auth != null && resource.data.author.uid == request.auth.uid;
      
      match /comments/{commentId} {
        allow read: if true;
        allow create: if request.auth != null;
        allow update, delete: if request.auth != null && resource.data.author.uid == request.auth.uid;
      }
    }

    // Weekly Journals
    match /journal_entries/{entryId} {
      allow read: if true;
      allow create: if request.auth != null && request.resource.data.uid == request.auth.uid;
      allow update, delete: if request.auth != null && resource.data.uid == request.auth.uid;
    }

    // Notifications
    match /notifications/{notificationId} {
        // Recipient can read their own notifications
        allow read: if request.auth != null && resource.data.recipientUid == request.auth.uid;
        // Any authenticated user can create a notification (sender)
        allow create: if request.auth != null; 
        // Recipient can update (mark as read)
        allow update: if request.auth != null && resource.data.recipientUid == request.auth.uid;
        // Recipient can delete
        allow delete: if request.auth != null && resource.data.recipientUid == request.auth.uid;
    }
  }
}
